<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/commandHandler.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/commandHandler.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import fs from "fs";
import path from "path";
import { pathToFileURL } from "url";

/**
 * Maps the original file path > command name.
 * Used to maintain command consistency.
 * @type {Map&lt;string, string>}
 */
const fileCommandMap = new Map();

/**
 * Load a single command file from disk.
 *
 * @param {string} fullPath - Full path to the command file.
 * @param {Map&lt;string, object>} commandsMap - The central map storing all commands.
 * @returns {Promise&lt;void>}
 */
async function loadCommandFile(fullPath, commandsMap) {
  try {
    const fileUrl = pathToFileURL(fullPath).href;

    // Import the command module
    const module = await import(fileUrl);
    const command = module.default;

    // Validate structure
    if (!command || typeof command.execute !== "function") {
      console.warn(`âš ï¸ Skipped invalid command: ${fullPath}`);
      return;
    }

    // Set defaults
    command.category = command.category || path.basename(path.dirname(fullPath));
    command.usage = command.usage || "No usage specified";
    command.cooldown = command.cooldown || 0;
    command.aliases = command.aliases || [];

    // Register command
    commandsMap.set(command.name, command);
    fileCommandMap.set(fullPath, command.name);

    // Register aliases
    for (const alias of command.aliases) {
      commandsMap.set(alias, { ...command, aliasedFrom: command.name });
    }

    console.log(`ðŸŸ¢ Loaded: ${command.name} (${fullPath})`);
  } catch (err) {
    console.error(`âŒ Failed to load command: ${fullPath}`);
    console.error(err);
  }
}

/**
 * Recursively load all commands inside the /commands directory.
 *
 * @param {string} dir - Directory path to read.
 * @param {Map&lt;string, object>} commandsMap - The map that stores all command objects.
 * @returns {Promise&lt;void>}
 */
async function loadDir(dir, commandsMap) {
  const files = fs.readdirSync(dir, { withFileTypes: true });

  for (const file of files) {
    const fullPath = path.join(dir, file.name);

    if (file.isDirectory()) {
      await loadDir(fullPath, commandsMap);
    } else if (file.isFile() &amp;&amp; file.name.endsWith(".js")) {
      await loadCommandFile(fullPath, commandsMap);
    }
  }
}

/**
 * Print a formatted summary of all loaded commands.
 *
 * @param {Map&lt;string, object>} commandsMap - Map of all loaded commands and aliases.
 */
function logSummary(commandsMap) {
  const categories = {};
  let aliasCount = 0;

  for (const [key, cmd] of commandsMap) {
    if (cmd.aliasedFrom) {
      aliasCount++;
      continue;
    }

    if (!categories[cmd.category]) categories[cmd.category] = [];
    categories[cmd.category].push(cmd.name);
  }

  console.log("\n========== COMMAND SUMMARY ==========");

  for (const cat of Object.keys(categories)) {
    console.log(`ðŸ“ ${cat}: ${categories[cat].join(", ")}`);
  }

  console.log(`ðŸ”— Aliases loaded: ${aliasCount}`);
  console.log(`ðŸ“¦ Total commands: ${commandsMap.size}`);
  console.log("=====================================\n");
}

/**
 * Load all commands from /commands.  
 *
 * @returns {Promise&lt;Map&lt;string, object>>} - A map of all loaded commands.
 */
export async function loadCommands() {
  const commands = new Map();

  await loadDir(path.resolve("./commands"), commands);
  logSummary(commands);

  return commands;
}

/**
 * Check and apply cooldown for a command.
 *
 * @param {object} command - The command object with a `cooldown` property.
 * @param {string} userId - The ID of the user executing the command.
 * @returns {number} Remaining cooldown (in seconds). Returns 0 if ready.
 */
export function checkCooldown(command, userId) {
  if (!command.cooldowns) {
    command.cooldowns = new Map();
  }

  const now = Date.now();
  const cooldownMs = command.cooldown * 1000;

  // No cooldown configured
  if (cooldownMs === 0) return 0;

  // Check if user is on cooldown
  if (command.cooldowns.has(userId)) {
    const expires = command.cooldowns.get(userId);
    if (now &lt; expires) {
      return Math.ceil((expires - now) / 1000);
    }
  }

  // Apply cooldown
  command.cooldowns.set(userId, now + cooldownMs);
  return 0;
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#checkCooldown">checkCooldown</a></li><li><a href="global.html#commands">commands</a></li><li><a href="global.html#fileCommandMap">fileCommandMap</a></li><li><a href="global.html#loadCommandFile">loadCommandFile</a></li><li><a href="global.html#loadCommands">loadCommands</a></li><li><a href="global.html#loadDir">loadDir</a></li><li><a href="global.html#logSummary">logSummary</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Sat Dec 13 2025 02:55:31 GMT+1100 (Australian Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
